# 协程
## 协程的定义
应用程序是一个进程，一个进程有多个操作线程，而并发处理的部分被称作协程
* 并发：一个程序中不同线程（比如两个函数）在一段时间交替进行（不是同时进行），或者说不同的任务在交错推进
* 并行：真正意义上的同时进行
1. `runtime.GOMAXPROCS(n)`（n>1)可以将协程分割到n个处理器上
   规则：协程的数量 > 1 + GOMAXPROCS > 1
2. 使用命令行指定核心数
   ![[decide-the-num-of-cpu.png]]
3. `time.Sleep()`括号中表示函数或协程的执行的暂停时间，单位为纳秒（1 s = 1 * 1e9 ns）
4. main程序返回时，程序退出，不会等待其他非main协程的结束
5. **关键字go** 
   * 用法：在要执行的函数前加go就可以
   * 作用：创建并启动一个协程
   * 注意：需要小心main的过早退出导致某些协程未进行完
# 通道(channel)
用来在协程之间通信的，协程需要通信才更有用
1. 声明格式
   `var xxx chan int/string/..`
   所有类型都可以用于通道，包括通道、函数等
2. 先进先出结构（那啥defer好像是后进先出啥的），保证顺序正确
3. 引用类型，请使用`make()`分配内存
4. **通信操作符 <-** 
	1. `ch <- int1`：用通道`ch`发送变量`int1` 
	2. `int2 = <- ch` :变量`int2`从通道`ch`获取数据
	3. `<- ch`可以单独使用，从通道接受一个值但直接丢弃，可以放在`if`中验证通道状态或者实现同步，下面这个例子就实现了同步![[the-special-use-of-chan.png]]
5. 死锁（deadlock）
   指的一些协程彼此等待释放或写入资源，结果都不动
	1. 条件
		1. **互斥**：资源不能被共享，一次只能被一个实体使用
		2. **持有并等待**：实体持有资源并等待其他资源
		3. **不可抢占**：资源只能由持有者自愿释放
		4. **循环等待**：存在一个循环等待链
	2. 报错形式：`all goroutines are asleep-deadlock!`
6. 通道阻塞，由于通信同步且**无缓冲** ，所以在通道中的数据未被接收时，通道时被阻塞的，无法传入（接收者同理，也是可以阻塞的）
7. 这段代码第二段，如果一开始c被阻塞，会一直等到c空闲，完成第一段了，再执行第二段
   ```go
   c <- 10
   fmt.Println("sent",10)
   ```
   