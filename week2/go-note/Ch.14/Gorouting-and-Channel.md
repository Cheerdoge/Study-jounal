# 协程
## 协程的定义
应用程序是一个进程，一个进程有多个操作线程，而并发处理的部分被称作协程
* 并发：一个程序中不同线程（比如两个函数）在一段时间交替进行（不是同时进行），或者说不同的任务在交错推进
* 并行：真正意义上的同时进行
1. `runtime.GOMAXPROCS(n)`（n>1)可以将协程分割到n个处理器上
   规则：协程的数量 > 1 + GOMAXPROCS > 1
2. 使用命令行指定核心数
   ![[decide-the-num-of-cpu.png]]
3. `time.Sleep()`括号中表示函数或协程的执行的暂停时间，单位为纳秒（1 s = 1 * 1e9 ns）
4. main程序返回时，程序退出，不会等待其他非main协程的结束
5. **关键字go** 
   * 用法：在要执行的函数前加go就可以
   * 作用：创建并启动一个协程
   * 注意：需要小心main的过早退出导致某些协程未进行完
# 通道(channel)
用来在协程之间通信的，协程需要通信才更有用
1. 声明格式
   `var xxx chan int/string/..`
   所有类型都可以用于通道，包括通道、函数等
2. 先进先出结构（那啥defer好像是后进先出啥的），保证顺序正确
3. 引用类型，请使用`make()`分配内存
4. **通信操作符 <-** 
	1. `ch <- int1`：用通道`ch`发送变量`int1` 
	2. `int2 = <- ch` :变量`int2`从通道`ch`获取数据
	3. `<- ch`可以单独使用，从通道接受一个值但直接丢弃，可以放在`if`中验证通道状态或者实现同步，下面这个例子就实现了同步![[the-special-use-of-chan.png]]
5. 死锁（deadlock）
   指的一些协程彼此等待释放或写入资源，结果都不动
	1. 条件
		1. **互斥**：资源不能被共享，一次只能被一个实体使用
		2. **持有并等待**：实体持有资源并等待其他资源
		3. **不可抢占**：资源只能由持有者自愿释放
		4. **循环等待**：存在一个循环等待链
	2. 报错形式：`all goroutines are asleep-deadlock!`
6. 通道阻塞，由于通信同步且**无缓冲** ，所以在通道中的数据未被接收时，通道是被阻塞的，无法传入（接收者同理，也是可以阻塞的），会一直等到发送者接收者都准备好，执行完后继续下一段代码
7. 这段代码第二段，如果一开始由于接收者未准备好导致c被阻塞，会等到接收者准备好了，完成了这个发送接收操作，再执行第二段
   ```go
   c <- 10
   fmt.Println("sent",10)
   ```
8. 由于以上6、7点，可以通过这种机制实现不同协程同步化
9. 如何使用**带缓冲**的通道
   只需要在创建通道的时候设定他的缓冲即可，如下:
   `ch1 := make(chan type, buf)`
   其中`buf`就是这个通道可以同时容纳的元素个数，在这个缓冲被占满前或接收时缓冲变空之前都不会阻塞
10. 信号量模式，即限流，用于控制同时进行的gorouting数量
    利用缓冲实现信息流即通过在协程中先占用通道的缓冲，使其他协程因通道满载无法执行占用操作而等待，在函数结束前释放缓冲从而达到限制协程进行数量![[example-Semaphore-Pattern.png]]
    当然，也可以用一个函数包装生成通道的过程
11. 对通道使用for循环
    开启一个gorouting用for循环对一个通道不断发送数据，将这个通道传递给另一个gorouting使用`for v := range ch{}`就可以实现不断从中读取数据
12. 只发送通道与只接收通道
    在函数返回值中分别表示为`<-chan type`和`chan<- type`
    可以起保护作用，限制对这个通道的操作、
13. `ch = ch1`表示的是把`ch`重新赋值为`ch1`所表示的通道
## 关闭通道
1. `close（ch）`可以将通道标记为无法发送值，但是多次对一个通道使用会导致panic
2. 可以在创建通道后`defer close(ch)`

## 检测通道阻塞或被关闭
1. if大人来了`if v,ok := <-ch; ok{}`
2. 如果是在for循环中，就可以用条件增加一个breakv
3. `select`语句用于检测是否阻塞
  ```go
   select {
	case v, ok := <-ch:
	  if ok {
	    process(v)
	  } else {
	    fmt.Println("The channel is closed")
	  }
	default:
	  fmt.Println("The channel is blocked")
	}```
p.s `default`也可以用在switch中，因为有点忘了

## 使用`select`切换协程
```go
select {
case u:= <- ch1:
        ...
case v:= <- ch2:
        ...
        ...
default: // no value ready to be received
        ...
}
```
哪个好了执行哪个下面的语句，default是在都没好时执行的
可以配合`time.After()`实现超时通知