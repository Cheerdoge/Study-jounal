使用http包
1. **开启服务器**`err := http.ListenAndServe(":8080", nil)`指定端口
	nil处用于填写路由，如果自定义了一个路由就填入该路由的名字，如
	```go
	package main

import (
    "fmt"
    "net/http"
)

type MyHandler struct{}

func (h *MyHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    switch r.URL.Path {
    case "/":
        fmt.Fprintf(w, "Home Page")
    case "/about":
        fmt.Fprintf(w, "About Page")
    default:
        http.NotFound(w, r)
    }
}

func main() {
    handler := &MyHandler{}
    http.ListenAndServe(":9999", handler)
}
	```
3. **获取URL路径** 使用`r.URL.Path`
4. **获取用户输入** 如果req方法是POST且sss是一个输入域，用户的输入通过`req.FormValue("sss")`获取
	或者先执行`request.ParseForm()`，然后再获取 `request.Form["var1"]` 的第一个返回参数，如`var1, found := request.Form["var1"]`，其中found是个bool值，找到为真
5. **如何处理请求** 使用`http.HandleFunc("1",2)`,其中1是具体的url，如“/regsiter”，2是对应的函数名，这个处理函数要两个参数：第一个是 `ReponseWriter` 类型的 `w`；第二个是请求 `req`，表示为`(w http.ResponseWriter, req *http.Request)`
	1. `fmt.Fprint()` 和 `fmt.Fprintf()`完成向w的写入，如`fmt.Fprintf(w, "Hello,"+req.URL.Path[1:])`
	2. 也可以使用这种方式：`http.Handle("/", http.HandlerFunc(HFunc))`

	`HandlerFunc` 只是定义了上述 `HFunc` 签名的别名：
	
	```go
	type HandlerFunc func(ResponseWriter, *Request)
	```
	
	它是一个可以把普通的函数当做 HTTP 处理器 (`Handler`) 的适配器。如果函数 `f` 声明得合适，`HandlerFunc(f)` 就是一个执行 `f` 函数的 `Handler` 对象。
	
	`http.Handle()` 的第二个参数也可以是 `T` 类型的对象 `obj`：`http.Handle("/", obj)`。
	
	如果 `T` 有 `ServeHTTP()` 方法，那就实现了 http 的 `Handler` 接口：
	
	```go
	func (obj *Typ) ServeHTTP(w http.ResponseWriter, req *http.Request) {
		...
	}
	```
	
	这个用法也在 `Counter` 和 `Chan` 类型上使用。只要实现了 `http.Handler`，`http` 包就可以处理任何 HTTP 请求