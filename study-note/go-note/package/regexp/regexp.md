正则表达式，用来匹配字符串中的指定字符
编写正则模式 -> 编译为*regexp.Regexp -> 匹配/查找替换

# 正则表达式语法
## 基本语法

| 类别           | 语法               | 描述与示例                       |
| ------------ | ---------------- | --------------------------- |
| **字符匹配**     | `.`              | 匹配任意单个字符（默认不匹配换行，需s标志）      |
|              | `[abc]`          | 匹配 a、b 或 c 中的任意一个字符         |
|              | `[^abc]`         | 匹配任何不在 a、b 或 c 中的字符         |
|              | `[a-z]`          | 匹配 a 到 z 范围内的任意字符           |
|              | `[^a-z]`         | 匹配不在 a 到 z 范围内的任意字符         |
|              | `\d`             | 匹配数字，等同于 `[0-9]`            |
|              | `\D`             | 匹配非数字，等同于 `[^0-9]`          |
|              | `\w`             | 匹配单词字符（字母、数字、下划线）           |
|              | `\W`             | 匹配非单词字符                     |
|              | `\s`             | 匹配空白字符（空格、制表符、换行符等）         |
|              | `\S`             | 匹配非空白字符                     |
|              | `\t`, `\n`, `\r` | 匹配制表符、换行符、回车符               |
| **重复次数(量词)** | `*`              | 匹配前一个元素 0 次或多次（贪婪）          |
|              | `+`              | 匹配前一个元素 1 次或多次（贪婪）          |
|              | `?`              | 匹配前一个元素 0 次或 1 次（贪婪）        |
|              | `{n}`            | 匹配前一个元素恰好 n 次               |
|              | `{n,}`           | 匹配前一个元素至少 n 次               |
|              | `{n,m}`          | 匹配前一个元素 n 到 m 次（贪婪）         |
|              | `*?`             | 非贪婪匹配，匹配尽可能少的字符（0次或多次）      |
|              | `+?`             | 非贪婪匹配，匹配尽可能少的字符（1次或多次）      |
|              | `??`             | 非贪婪匹配，匹配尽可能少的字符（0次或1次）      |
| **位置锚点**     | `^`              | 匹配字符串开始（或多行模式下的行首）          |
|              | `$`              | 匹配字符串结束（或多行模式下的行尾）          |
|              | `\b`             | 匹配单词边界                      |
|              | `\B`             | 匹配非单词边界                     |
|              | `\A`             | 匹配字符串开始（不受多行模式影响）           |
|              | `\z`             | 匹配字符串结束（不受多行模式影响）           |
| **分组与捕获**    | `(abc)`          | 捕获分组，将括号内模式作为一个整体并记录匹配内容    |
|              | `(?:abc)`        | 非捕获分组，只分组不捕获                |
|              | `(?P<name>abc)`  | 命名捕获分组，可通过命名访问              |
|              | `${1}`, `${2}`   | 反向引用，引用之前捕获的分组              |
|              | `(?#comment)`    | 注释，不影响匹配                    |
| **断言**       | `(?=abc)`        | 正向先行断言，匹配后面跟着abc的位置         |
|              | `(?!abc)`        | 负向先行断言，匹配后面不跟着abc的位置        |
|              | `(?<=abc)`       | 正向后行断言，匹配前面是abc的位置          |
|              | `(?<!abc)`       | 负向后行断言，匹配前面不是abc的位置         |
| **逻辑与转义**    | `a\|b`           | 逻辑或，匹配 a 或 b                |
|              | `\`              | 转义字符，用于匹配特殊字符本身，如 `\.` 匹配点号 |
| **标志修饰**     | `(?i)`           | 不区分大小写                      |
|              | `(?s)`           | 单行模式，让`.`匹配所有字符包括换行         |
|              | `(?m)`           | 多行模式，影响`^`和`$`              |
|              | `(?U)`           | 非贪婪模式                       |
|              | `(?ismU)`        | 组合多个标志                      |
- `\d` = `[0-9]` (数字)
- `\D` = `[^0-9]` (非数字)
- `\w` = `[a-zA-Z0-9_]` (单词字符)
- `\W` = `[^a-zA-Z0-9_]` (非单词字符)
- `\s` = `[ \t\n\r\f\v]` (空白字符)
- `\S` = `[^ \t\n\r\f\v]` (非空白字符)
**贪婪**：尽可能多的匹配，**懒惰**相反

## 零宽断言
1. 回望，从匹配位置向后查询，如`(?<=exp)`，表示左边满足exp的文本不包含exp本身的内容
2. 前瞻，从匹配位置向前查询，如`(?=exp)`

## 捕获
使用正则表达式`()`可以把匹配的文本储存
步骤如下：
1. `regexp.MustCompile(``)`创建捕获组
2. `matches := re.FindStringSubmatch(text)`
3. matches[0]是完整字符串，后继元素按顺序满足的正则表达式的对应文本